#ifndef _BASSO_PARTITIONED_MESH_BLOCK_HEXA8_H_
#define _BASSO_PARTITIONED_MESH_BLOCK_HEXA8_H_

#include "Basso_MeshBlockHexa8.h"
#include "Basso_shape_functions.h"

namespace Basso
{
	
// ****************************************************************************************** //
/**
\brief Hexa8 mesh on a 3D block region that can be partitioned for parallel processing.

This class is similar to Basso_MeshBlockHexa8<T>, but allows for the mesh to be partitioned into contigous sub-blocks of elements for domain decomposition. 

*/
template<class T>
class Basso_PMeshBlockHexa8 : public Basso_MeshBlockHexa8<T>
{
	
public:
	/** Constructor, the number of partitions is intially set to 1*/
	Basso_PMeshBlockHexa8( int p=0 ) : Basso_MeshBlockHexa8<T>( ) { SetNumPartitions(1,1,1); pid_=p; }
		
	/** Constructor, using the 8 vertecies. The number of partitions is intially set to 1
	\param x1-x7 the eight vertecies
	\param p (default 0) the current active partition
	*/
	Basso_PMeshBlockHexa8( const T *x1, const T *x2, const T *x3, const T *x4,
		const T *x5, const T *x6, const T *x7, const T *x8, int p=0 ) : Basso_MeshBlockHexa8<T>(x1,x2,x3,x4,x5,x6,x7,x8) 
		{ SetNumPartitions(1,1,1); pid_=p;  }
		
	/** Constructor, using the 2 diagonal vertecies. The edges are assumed to be aligned with the x, y and z axis.
	The number of partitions is intially set to 1.
	\param x1-x7 the eight vertecies
	\param p (default 0) the current active partition
	*/
	Basso_PMeshBlockHexa8( const T *x1, const T *x7, int p=0  ) : Basso_MeshBlockHexa8<T>(x1,x7) 
		{ SetNumPartitions(1,1,1); pid_=p; }
	
	/** Sets the number of partitions in the 1, 2 and 3 directions
	\param np1 number of partitions in the 1-direction
	\param np2 number of partitions in the 2-direction
	\param np3 number of partitions in the 3-direction
	*/
	void SetNumPartitions( int np1, int np2, int np3 );
	/** returns the total number of partitions 
	\return the total number of partitions
	*/
	int	NumPartitions() const { return nproc1_*nproc2_*nproc3_; }
	
	/** Sets the approximate element size for the mesh 
	\param he the target element size
	*/
	virtual void SetElementSize( T he ); 
	
	/** Sets the current active partition
	\param p partition id (zero offset)
	*/
	void SetPID( int p ) { pid_=p; }
	
	/** Returns the number of nodes on the active partition
	\return number of nodes on the partition
	*/
	BASSO_IDTYPE NumNodes() const { return nnp1*nnp2*nnp3; }
	/** Returns the total number of nodes on the whole mesh
	\return total number of nodes
	*/
	BASSO_IDTYPE NumTotalNodes() const {  return this->nn1*this->nn2*this->nn3; }

	/** Returns the number of elements on the active partition
	\return number of elements on the partition
	*/
	BASSO_IDTYPE NumElements() const { return (nnp1-1)*(nnp2-1)*(nnp3-1); }
	/** Returns the total number of elements on the whole mesh
	\return total number of elements
	*/
	BASSO_IDTYPE NumTotalElements() const { return (this->nn1-1)*(this->nn2-1)*(this->nn3-1); }

	
	/** Sets node cord and element connectivity for the mesh for the active partition.
	The input values node and conn need to be of the proper size on input.  Also, the element connectivity is
	local, in that they refer to the columns of the node coordiante matrix node.  If you wish to have the 
	global ids use the global node id map that can be generated by
	GlobalNodeIDs
	\param node retuns with the node coordinate matrix
	\param conn returns the hexa8 element connectivity matrix with local node numbers.  
	*/
	virtual void SetMesh( Basso_Array2D<T> &node, Basso_Array2D<BASSO_IDTYPE> &conn ) const;
	
	/** Sets the global node id map for the curretn partition.  This is a map between the local node ids 
	corresponding to the columns of the node coordinate matrix and the global node ids (possibly for dof mapping)
	\param gnids on return has the global node id 
	*/
	void GlobalNodeIDs( Basso_Array<BASSO_IDTYPE> &gnids ) const;

	/** Returns the connectivity of the side elements for a given side.  The
	element connectivity uses the local node numbering.
	\param conn on return hsa the element connectivity
	\param id side id
	*/
	virtual void SideSegs( Basso_Array2D<BASSO_IDTYPE> &conn, int id ) const;
	
	/** Returns the connectivity of the edge elements for a given edge.  The
	element connectivity uses the local node numbering.
	\param conn on return hsa the element connectivity
	\param id edge id
	*/
	virtual void EdgeSegs( Basso_Array2D<BASSO_IDTYPE> &conn, int id ) const;
	
	
protected:
	void SetNumberLocalNodes();
	void GetIJK( int &I, int &J, int &K ) const;
	
protected:
	int nproc1_, nproc2_, nproc3_;
	int nnp1, nnp2, nnp3;
	int pid_;
	
};

template<class T>
void Basso_PMeshBlockHexa8<T>::SetNumberLocalNodes() 
{
	nnp1=ceil((this->nn1-1)/nproc1_)+1; this->nn1=(nnp1-1)*nproc1_+1;  
	nnp2=ceil((this->nn2-1)/nproc2_)+1; this->nn2=(nnp2-1)*nproc2_+1;  
	nnp3=ceil((this->nn3-1)/nproc3_)+1; this->nn3=(nnp3-1)*nproc3_+1;  
}

 
template<class T>
void Basso_PMeshBlockHexa8<T>::SetElementSize( T he )
{
	Basso_Numeric l1, l2, l3;
	l1 = abs( 0.25*(this->v1[0]+this->v5[0]+this->v8[0]+this->v4[0]) 
				- 0.25*(this->v2[0]+this->v3[0]+this->v6[0]+this->v7[0]) );
	l2 = abs( 0.25*(this->v1[1]+this->v5[1]+this->v2[1]+this->v6[1]) 
				- 0.25*(this->v3[1]+this->v4[1]+this->v7[1]+this->v8[1]) );
	l3 = abs( 0.25*(this->v1[2]+this->v2[2]+this->v3[2]+this->v4[2])
				- 0.25*(this->v5[2]+this->v6[2]+this->v7[2]+this->v8[2]) );
	
	this->nn1 = ceil(l1/he)+1;
	this->nn2 = ceil(l2/he)+1;
	this->nn3 = ceil(l3/he)+1;
	
	SetNumberLocalNodes();
}

template<class T>
void Basso_PMeshBlockHexa8<T>::SetNumPartitions( int np1, int np2, int np3 )
{ 
	nproc1_=np1; nproc2_=np2; nproc3_=np3; 
	SetNumberLocalNodes();
}
		
template<class T>		
void Basso_PMeshBlockHexa8<T>::GetIJK( int &I, int &J, int &K ) const
{
	int p12 = nproc1_*nproc2_;
	int IJ = pid_ % p12;
	I = IJ % nproc1_;
	J = IJ / nproc1_;
	K = pid_ / p12;
}

template<class T>
void Basso_PMeshBlockHexa8<T>::SetMesh( Basso_Array2D<T> &node, Basso_Array2D<BASSO_IDTYPE> &conn ) const
{
	// compute the corners for this partition region
	T vl1[3], vl2[3], vl3[3], vl4[3], vl5[3], vl6[3], vl7[3], vl8[3];
	
	int I, J, K;
	GetIJK(I,J,K);
	
	T xi0, eta0, zeta0, xi, eta, zeta, dxi, deta, dzeta, N[8];
	dxi = 2.0/nproc1_; deta = 2.0/nproc2_; dzeta = 2.0/nproc3_;
	xi0 = I*dxi-1; eta0 = J*deta-1; zeta0 = K*dzeta-1; 
	
	xi=xi0; eta=eta0; zeta=zeta0;
	shape_hexa8( N, 1, xi, eta, zeta);
	for ( int s=0; s<3; ++s )
		vl1[s] = N[0]*this->v1[s]+N[1]*this->v2[s]+N[2]*this->v3[s]+N[3]*this->v4[s]+N[4]*this->v5[s]+N[5]*this->v6[s]+N[6]*this->v7[s]+N[7]*this->v8[s];
	
	xi=xi0+dxi; eta=eta0; zeta=zeta0;
	shape_hexa8( N, 1, xi, eta, zeta);
	for ( int s=0; s<3; ++s )
		vl2[s] = N[0]*this->v1[s]+N[1]*this->v2[s]+N[2]*this->v3[s]+N[3]*this->v4[s]+N[4]*this->v5[s]+N[5]*this->v6[s]+N[6]*this->v7[s]+N[7]*this->v8[s];
	
	xi=xi0+dxi; eta=eta0+deta; zeta=zeta0;
	shape_hexa8( N, 1, xi, eta, zeta);
	for ( int s=0; s<3; ++s )
		vl3[s] = N[0]*this->v1[s]+N[1]*this->v2[s]+N[2]*this->v3[s]+N[3]*this->v4[s]+N[4]*this->v5[s]+N[5]*this->v6[s]+N[6]*this->v7[s]+N[7]*this->v8[s];
	
	xi=xi0; eta=eta0+deta; zeta=zeta0;
	shape_hexa8( N, 1, xi, eta, zeta);
	for ( int s=0; s<3; ++s )
		vl4[s] = N[0]*this->v1[s]+N[1]*this->v2[s]+N[2]*this->v3[s]+N[3]*this->v4[s]+N[4]*this->v5[s]+N[5]*this->v6[s]+N[6]*this->v7[s]+N[7]*this->v8[s];
	
	xi=xi0; eta=eta0; zeta=zeta0+dzeta;
	shape_hexa8( N, 1, xi, eta, zeta);
	for ( int s=0; s<3; ++s )
		vl5[s] = N[0]*this->v1[s]+N[1]*this->v2[s]+N[2]*this->v3[s]+N[3]*this->v4[s]+N[4]*this->v5[s]+N[5]*this->v6[s]+N[6]*this->v7[s]+N[7]*this->v8[s];
	
	xi=xi0+dxi; eta=eta0; zeta=zeta0+dzeta;
	shape_hexa8( N, 1, xi, eta, zeta);
	for ( int s=0; s<3; ++s )
		vl6[s] = N[0]*this->v1[s]+N[1]*this->v2[s]+N[2]*this->v3[s]+N[3]*this->v4[s]+N[4]*this->v5[s]+N[5]*this->v6[s]+N[6]*this->v7[s]+N[7]*this->v8[s];
	
	xi=xi0+dxi; eta=eta0+deta; zeta=zeta0+dzeta;
	shape_hexa8( N, 1, xi, eta, zeta);
	for ( int s=0; s<3; ++s )
		vl7[s] = N[0]*this->v1[s]+N[1]*this->v2[s]+N[2]*this->v3[s]+N[3]*this->v4[s]+N[4]*this->v5[s]+N[5]*this->v6[s]+N[6]*this->v7[s]+N[7]*this->v8[s];
	
	xi=xi0; eta=eta0+deta; zeta=zeta0+dzeta;
	shape_hexa8( N, 1, xi, eta, zeta);
	for ( int s=0; s<3; ++s )
		vl8[s] = N[0]*this->v1[s]+N[1]*this->v2[s]+N[2]*this->v3[s]+N[3]*this->v4[s]+N[4]*this->v5[s]+N[5]*this->v6[s]+N[6]*this->v7[s]+N[7]*this->v8[s];
	
	
	// 
	node.Resize( 3, NumNodes() );
	node_array_3d( vl1[0], vl1[1], vl1[2],   vl2[0], vl2[1], vl2[2], 
				vl3[0], vl3[1], vl3[2],   vl4[0], vl4[1], vl4[2],
				vl4[0], vl5[1], vl5[2],   vl6[0], vl6[1], vl6[2],
				vl7[0], vl7[1], vl7[2],   vl8[0], vl8[1], vl8[2],
                nnp1, nnp2, nnp3, node.Data(), node.LDA(),
				this->bias1, this->bf1, this->bias2, this->bf2, this->bias3, this->bf3 );
				
	conn.Resize( 8, NumElements() );
	BASSO_IDTYPE cptrn[8];
	cptrn[0]=0;           cptrn[1]=1;           cptrn[2]=nnp1+1;           cptrn[3]=nnp1;
	cptrn[4]=0+nnp1*nnp2; cptrn[5]=1+nnp1*nnp2; cptrn[6]=nnp1+1+nnp1*nnp2; cptrn[7]=nnp1+nnp1*nnp2;
	gen_conn_3d( cptrn, 8, nnp1-1, nnp2-1, nnp3-1, conn.Data(), conn.LDA() );
}

template<class T>
void Basso_PMeshBlockHexa8<T>::GlobalNodeIDs( Basso_Array<BASSO_IDTYPE> &gnids ) const
{
	int I, J, K;
	BASSO_IDTYPE n, nl=(this->nn1)*(this->nn2), nr=(this->nn1), dnr=nr-nnp1, dnl=nl-nr*nnp2;
	GetIJK(I,J,K);
	
	BASSO_IDTYPE *gptr = gnids.Data();
	n = K*nl + J*nr*(this->nnp2 - 1) + I*(this->nnp1 - 1);
	for ( int k=0; k<nnp3; ++k, n+=dnl )
		for ( int j=0; j<nnp2; ++j, n+=dnr )
			for ( int i=0; i<nnp1; ++i, ++n, ++gptr )
				*gptr = n;
}


template<class T>
void Basso_PMeshBlockHexa8<T>::SideSegs( Basso_Array2D<BASSO_IDTYPE> &conn, int id )  const
{
	int I, J, K;
	GetIJK(I,J,K);
	
	BASSO_IDTYPE cptrn[4];
	
	switch ( id )
	{
		case 0:  // -2 normal face 
		if ( J!=0 ) return;
		
		conn.Resize(4, (nnp1-1)*(nnp3-1) );
		cptrn[0]=0; cptrn[1]=1; cptrn[2]=nnp1*nnp2+1; cptrn[3]=nnp1*nnp2;	
		gen_conn_2d( cptrn, 4, nnp1-1, nnp3-1, 
			conn.Data(), conn.LDA(), 1, nnp1*(nnp2-1)+2 );
		break;
		
		case 1:  // +1 normal face 
		if ( I!=nproc1_-1 ) return;

	 	conn.Resize(4, (nnp2-1)*(nnp3-1) );
		cptrn[0]=nnp1-1; cptrn[1]=cptrn[0]+nnp1; 
		cptrn[2]=cptrn[1]+nnp1*nnp2; cptrn[3]=cptrn[2]-nnp1;	
		gen_conn_2d( cptrn, 4, nnp2-1, nnp3-1, 
			conn.Data(), conn.LDA(), nnp1, 2*nnp1 );
		break;
		
		case 2:  // +2 normal face 
		
		if ( J!=nproc2_-1 ) return;
		
		conn.Resize(4, (nnp1-1)*(nnp3-1) );
		cptrn[0]=nnp1*(nnp2-1)+1; cptrn[1]=nnp1*(nnp2-1); 
		cptrn[2]=nnp1*(nnp2-1)+nnp1*nnp2; cptrn[3]=cptrn[2]+1;	
		gen_conn_2d( cptrn, 4, nnp1-1, nnp3-1, 
			conn.Data(), conn.LDA(), 1, nnp1*(nnp2-1)+2 );
		break;
		
		case 3:  // -1 normal face 
		
		if ( I!=0 ) return;
		
		conn.Resize(4, (nnp2-1)*(nnp3-1) );
		cptrn[0]=nnp1; cptrn[1]=0; 
		cptrn[2]=nnp1*nnp2; cptrn[3]=cptrn[2]+nnp1;	
		gen_conn_2d( cptrn, 4, nnp2-1, nnp3-1, 
			conn.Data(), conn.LDA(), nnp1, 2*nnp1 );
		break;
		
		case 4:  // -3 normal face 
		
		if ( K!=0 ) return;
		
		conn.Resize(4, (nnp2-1)*(nnp1-1) );
		cptrn[0]=1; cptrn[1]=0; 
		cptrn[2]=nnp1; cptrn[3]=nnp1+1;	
		gen_conn_2d( cptrn, 4, nnp1-1, nnp2-1, 
			conn.Data(), conn.LDA(), 1, 2 );
		break;
		
		case 5:  // +3 normal face 
		
		if ( K!=nproc3_-1 ) return;
		
		conn.Resize(4, (nnp2-1)*(nnp1-1) );
		cptrn[0]=(nnp3-1)*nnp1*nnp2; cptrn[1]=cptrn[0]+1; 
		cptrn[2]=cptrn[1]+nnp1; cptrn[3]=cptrn[2]-1;	
		gen_conn_2d( cptrn, 4, nnp1-1, nnp2-1, 
			conn.Data(), conn.LDA(), 1, 2 );
		break;
		
		default:
		cout << "Basso_PMeshBlockHexa8<T>::SideSegs unknown side id=" << id << "\n";
		
	} 
}


template<class T>
void Basso_PMeshBlockHexa8<T>::EdgeSegs( Basso_Array2D<BASSO_IDTYPE> &conn, int id ) const
{
	
	int I, J, K;
	GetIJK(I,J,K);
	BASSO_IDTYPE cptrn[2];
	
	switch ( id )
	{
		case 0:  // edge connecting vertex 0 to 1
		if ( J!=0 || K!=0 ) return;
		
		conn.Resize(2, nnp1-1 );
		cptrn[0]=0; cptrn[1]=1;	
		gen_conn_1d( cptrn, 2, nnp1-1, conn.Data(), conn.LDA(), 1 );
		break;
					
		case 1:  // edge connecting vertex 1 to 2
		if ( I!=nproc1_-1 || K!=0 ) return;
		
		conn.Resize(2, nnp2-1 );
		cptrn[0]=nnp1-1; cptrn[1]=cptrn[0]+nnp1;	
		gen_conn_1d( cptrn, 2, nnp2-1, conn.Data(), conn.LDA(), nnp1 );
		break;
							
		case 2:  // edge connecting vertex 2 to 3
		if ( J!=nproc2_-1 || K!=0 ) return;
		
		conn.Resize(2, nnp1-1 );
		cptrn[0]=nnp1*nnp2-1; cptrn[1]=cptrn[0]-1;	
		gen_conn_1d( cptrn, 2, nnp1-1, conn.Data(), conn.LDA(), -1 );
		break;
			
		case 3:  // edge connecting vertex 3 to 0
		if ( I!=0 || K!=0 ) return;
		
		conn.Resize(2, nnp2-1 );
		cptrn[0]=(nnp2-1)*nnp1; cptrn[1]=cptrn[0]-nnp1;	
		gen_conn_1d( cptrn, 2, nnp2-1, conn.Data(), conn.LDA(), -nnp1 );
		break;
				
		case 4:  // edge connecting vertex 4 to 5
		if ( J!=0 || K!=nproc3_-1 ) return;
		
		conn.Resize(2, nnp1-1 );
		cptrn[0]=(nnp3-1)*nnp1*nnp2; cptrn[1]=cptrn[0]+1;	
		gen_conn_1d( cptrn, 2, nnp1-1, conn.Data(), conn.LDA(), 1 );
		break;
					
		case 5:  // edge connecting vertex 5 to 6
		if ( I!=nproc1_-1 || K!=nproc3_-1 ) return;
		
		conn.Resize(2, nnp2-1 );
		cptrn[0]=(nnp3-1)*nnp1*nnp2+(nnp1-1); cptrn[1]=cptrn[0]+nnp1;	
		gen_conn_1d( cptrn, 2, nnp2-1, conn.Data(), conn.LDA(), nnp1 );
		break;
							
		case 6:  // edge connecting vertex 6 to 7
		if ( J!=nproc2_-1 || K!=nproc3_-1 ) return;
		
		conn.Resize(2, nnp1-1 );
		cptrn[0]=nnp1*nnp2*nnp3-1; cptrn[1]=cptrn[0]-1;	
		gen_conn_1d( cptrn, 2, nnp1-1, conn.Data(), conn.LDA(), -1 );
		break;
			
		case 7:  // edge connecting vertex 7 to 4
		if ( I!=0 || K!=nproc3_-1 ) return;
		
		conn.Resize(2, nnp2-1 );
		cptrn[0]=nnp1*(nnp2*nnp3-1); cptrn[1]=cptrn[0]-nnp1;	
		gen_conn_1d( cptrn, 2, nnp2-1, conn.Data(), conn.LDA(), -nnp1 );
		break;
						
		default:
		std:cout << "Basso_PMeshBlockHexa8<T>::EdgeSegs unknown edge id=" << id << "\n";
		
	} 	
	
}

} // end namespace

#endif
